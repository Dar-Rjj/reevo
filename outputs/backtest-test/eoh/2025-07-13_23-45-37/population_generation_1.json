[
     {
          "algorithm": "The new algorithm calculates the difference between a 5-day and 20-day moving average of the true range, then adjusts this difference by the rate of change in the closing prices over 7 days, normalized by its own standard deviation, to capture short-term shifts in price volatility and momentum.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def true_range(data):\n        high_low = data['high'] - data['low']\n        high_close_prev = (data['high'] - data['close'].shift(1)).abs()\n        low_close_prev = (data['low'] - data['close'].shift(1)).abs()\n        return pd.concat([high_low, high_close_prev, low_close_prev], axis=1).max(axis=1)\n    \n    tr = true_range(df)\n    short_ma_tr = tr.rolling(window=5).mean()\n    long_ma_tr = tr.rolling(window=20).mean()\n    tr_diff = short_ma_tr - long_ma_tr\n    close_momentum = df['close'].pct_change(periods=7)\n    close_momentum_normalized = (close_momentum - close_momentum.mean()) / close_momentum.std()\n    heuristics_matrix = (tr_diff * close_momentum_normalized).fillna(0)\n    return heuristics_matrix",
          "objective": -0.03027,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the difference between a short-term and long-term moving average of the true range, then adjusts this difference by the normalized rate of change in the closing prices, aiming to capture shifts in price volatility and momentum.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def true_range(data):\n        high_low = data['high'] - data['low']\n        high_close_prev = (data['high'] - data['close'].shift(1)).abs()\n        low_close_prev = (data['low'] - data['close'].shift(1)).abs()\n        return pd.concat([high_low, high_close_prev, low_close_prev], axis=1).max(axis=1)\n    \n    tr = true_range(df)\n    short_ma_tr = tr.rolling(window=7).mean()\n    long_ma_tr = tr.rolling(window=21).mean()\n    tr_diff = short_ma_tr - long_ma_tr\n    close_momentum = df['close'].pct_change(periods=10)\n    close_momentum_normalized = (close_momentum - close_momentum.mean()) / close_momentum.std()\n    heuristics_matrix = (tr_diff * close_momentum_normalized).fillna(0)\n    return heuristics_matrix",
          "objective": -0.02968,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite alpha factor by adjusting the parameter settings for the short and long moving averages, the momentum lookback, and the volatility window, then combines these with different weights to produce a final heuristic score.",
          "code": "def heuristics_v2(df):\n    # Compute moving averages for short and long terms\n    short_window = 10\n    long_window = 50\n    df['SMA_Short'] = df['close'].rolling(window=short_window).mean()\n    df['SMA_Long'] = df['close'].rolling(window=long_window).mean()\n    \n    # Momentum factor: difference between current close and close 'n' days ago\n    n_days = 20\n    df['Momentum'] = df['close'] - df['close'].shift(n_days)\n    \n    # Volatility factor: standard deviation of daily returns over a window\n    vol_window = 60\n    df['Daily_Return'] = df['close'].pct_change()\n    df['Volatility'] = df['Daily_Return'].rolling(window=vol_window).std()\n    \n    # Combine the factors into a single heuristic score with adjusted weights\n    df['Heuristic_Score'] = (df['SMA_Short'] - df['SMA_Long']) * 1.5 + df['Momentum'] * 0.8 - df['Volatility'] * 0.5\n    \n    heuristics_matrix = df['Heuristic_Score']\n    \n    return heuristics_matrix",
          "objective": -0.02402,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm synthesizes a composite score by integrating normalized indicators of relative strength, directional movement, and price oscillation to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the Relative Strength Index (RSI)\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    \n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    \n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate the Directional Movement Index (DMI)\n    up_move = df['high'] - df['high'].shift(1)\n    down_move = df['low'].shift(1) - df['low']\n    \n    plus_dm = up_move.where((up_move > down_move) & (up_move > 0), 0).fillna(0)\n    minus_dm = down_move.where((down_move > up_move) & (down_move > 0), 0).fillna(0)\n    \n    tr = pd.concat([df['high'] - df['low'], (df['high'] - df['close'].shift()).abs(), (df['low'] - df['close'].shift()).abs()], axis=1).max(axis=1)\n    atr = tr.rolling(window=14).mean()\n    \n    plus_di = 100 * (plus_dm.rolling(window=14).sum() / atr)\n    minus_di = 100 * (minus_dm.rolling(window=14).sum() / atr)\n    \n    dmi = plus_di - minus_di\n    \n    # Calculate the Price Oscillator\n    short_ema = df['close'].ewm(span=12, adjust=False).mean()\n    long_ema = df['close'].ewm(span=26, adjust=False).mean()\n    price_oscillator = short_ema - long_ema\n    \n    # Normalize the indicators\n    rsi_normalized = (rsi - 50) / 50\n    dmi_normalized = dmi / 100\n    po_normalized = (price_oscillator - price_oscillator.mean()) / price_oscillator.std()\n    \n    # Combine the normalized indicators into a single heuristic score\n    heuristics_matrix = (rsi_normalized + dmi_normalized + po_normalized).fillna(0)\n    \n    return heuristics_matrix",
          "objective": -0.02279,
          "other_inf": null
     }
]